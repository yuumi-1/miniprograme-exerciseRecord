"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));
var _emit = _interopRequireDefault(require("../event/emit"));
var _controller = _interopRequireDefault(require("../event/controller"));
var _canvasElement = _interopRequireDefault(require("./canvas-element"));
var _util = require("@antv/util");
var DOMUtil = _interopRequireWildcard(require("../util/dom"));
var _container = _interopRequireDefault(require("./container"));
var _group = _interopRequireDefault(require("./group"));
var _requestAnimationFrame = require("../util/requestAnimationFrame");
var _lang = _interopRequireDefault(require("./lang"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getPixelRatio = DOMUtil.getPixelRatio,
  getDomById = DOMUtil.getDomById,
  getWidth = DOMUtil.getWidth,
  getHeight = DOMUtil.getHeight,
  isCanvasElement = DOMUtil.isCanvasElement;
var Canvas = /*#__PURE__*/function (_EventEmit) {
  (0, _inherits2.default)(Canvas, _EventEmit);
  var _super = (0, _createSuper2.default)(Canvas);
  function Canvas(cfg) {
    var _this;
    (0, _classCallCheck2.default)(this, Canvas);
    _this = _super.call(this);
    var title = cfg.title;
    var ariaLabel = title ? (0, _util.substitute)(_lang.default.general.withTitle, {
      title: title
    }) : _lang.default.general.title;
    _this._attrs = (0, _util.mix)({
      type: 'canvas',
      children: [],
      ariaLabel: ariaLabel
    }, cfg);
    _this._initPixelRatio();
    _this._initCanvas();
    return _this;
  }
  (0, _createClass2.default)(Canvas, [{
    key: "get",
    value: /* eslint-enable */
    function get(name) {
      return this._attrs[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this._attrs[name] = value;
    }
  }, {
    key: "_initPixelRatio",
    value: function _initPixelRatio() {
      var pixelRatio = this.get('pixelRatio');
      if (!pixelRatio) {
        this.set('pixelRatio', getPixelRatio());
      }
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw() {
      var context = this._attrs.context;
      var el = this._attrs.el;
      context && context.clearRect && context.clearRect(0, 0, el.width, el.height);
    }
  }, {
    key: "_initCanvas",
    value: function _initCanvas() {
      var el = this.get('el');
      var context = this.get('context');
      if (!el && !context) {
        throw new Error('Please specify the id, el or context of the chart!');
      }
      var canvas;
      if (el) {
        // DOMElement or String
        canvas = (0, _util.isString)(el) ? getDomById(el) : el;
      } else {
        // 说明没有指定el
        canvas = _canvasElement.default.create(context);
      }
      if (context && canvas && !canvas.getContext) {
        canvas.getContext = function () {
          return context;
        };
      }
      var width = this.get('width') || getWidth(canvas) || canvas.width;
      var height = this.get('height') || getHeight(canvas) || canvas.height;
      this.set('canvas', this);
      this.set('el', canvas);
      this.set('context', context || canvas.getContext('2d'));
      this.changeSize(width, height);
      // 初始化事件控制器
      var eventController = new _controller.default({
        canvas: this,
        el: canvas
      });
      this.set('eventController', eventController);
    }
  }, {
    key: "changeSize",
    value: function changeSize(width, height) {
      var pixelRatio = this.get('pixelRatio');
      var canvasDOM = this.get('el'); // HTMLCanvasElement or canvasElement
      // 浏览器环境设置style样式
      if (canvasDOM.style) {
        canvasDOM.style.width = width + 'px';
        canvasDOM.style.height = height + 'px';
      }
      if (isCanvasElement(canvasDOM)) {
        canvasDOM.width = width * pixelRatio;
        canvasDOM.height = height * pixelRatio;
        if (pixelRatio !== 1) {
          var ctx = this.get('context');
          ctx.scale(pixelRatio, pixelRatio);
        }
      }
      this.set('width', width);
      this.set('height', height);
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var pixelRatio = this.get('pixelRatio');
      var width = this.get('width');
      return width * pixelRatio;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var pixelRatio = this.get('pixelRatio');
      var height = this.get('height');
      return height * pixelRatio;
    }
  }, {
    key: "getPointByClient",
    value: function getPointByClient(clientX, clientY) {
      var el = this.get('el');
      var bbox = el.getBoundingClientRect();
      var width = bbox.right - bbox.left;
      var height = bbox.bottom - bbox.top;
      return {
        x: (clientX - bbox.left) * (el.width / width),
        y: (clientY - bbox.top) * (el.height / height)
      };
    }
  }, {
    key: "_beginDraw",
    value: function _beginDraw() {
      this._attrs.toDraw = true;
    }
  }, {
    key: "_endDraw",
    value: function _endDraw() {
      this._attrs.toDraw = false;
      this.emit('afterdraw', {});
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this2 = this;
      var drawInner = function drawInner() {
        _this2.set('animateHandler', (0, _requestAnimationFrame.requestAnimationFrame)(function () {
          _this2.set('animateHandler', undefined);
          if (_this2.get('toDraw')) {
            drawInner();
          }
        }));
        _this2.beforeDraw();
        try {
          var context = _this2._attrs.context;
          _this2.drawChildren(context);
          // 支付宝，微信小程序，需要调context.draw才能完成绘制， 所以这里直接判断是否有.draw方法
          if (context.draw) {
            context.draw();
          }
          // 设置无障碍文本
          _this2.setAriaLabel();
        } catch (ev) {
          console.warn('error in draw canvas, detail as:');
          console.warn(ev);
          _this2._endDraw();
        }
        _this2._endDraw();
      };
      if (this.get('destroyed')) {
        return;
      }
      if (this.get('animateHandler')) {
        this._beginDraw();
      } else {
        drawInner();
      }
    }
    // 设置无障碍文本
  }, {
    key: "setAriaLabel",
    value: function setAriaLabel() {
      var el = this._attrs.el;
      var ariaLabel = this._getAriaLabel();
      if (ariaLabel && el.setAttribute) {
        el.setAttribute('aria-label', ariaLabel);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.get('destroyed')) {
        return;
      }
      // 需要清理 canvas 画布内容，否则会导致 spa 应用 ios 下 canvas 白屏
      // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12
      // https://github.com/antvis/F2/issues/630
      var el = this.get('el');
      el.width = 0;
      el.height = 0;
      this.clear();
      this._attrs = {};
      this.set('destroyed', true);
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return this.get('destroyed');
    }
  }]);
  return Canvas;
}(_emit.default); // @ts-ignore
(0, _util.mix)(Canvas.prototype, _container.default, {
  getGroupClass: function getGroupClass() {
    return _group.default;
  }
});
var _default = Canvas;
exports.default = _default;