"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));
var _util = require("@antv/util");
var DOMUtil = _interopRequireWildcard(require("../../util/dom"));
var _shape = _interopRequireDefault(require("./shape"));
var _rect = _interopRequireDefault(require("../../util/rect"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var measureText = DOMUtil.measureText;
var textWidthCacheCounter = 0;
var textWidthCache = {};
var TEXT_CACHE_MAX = 5000;
var Text = /*#__PURE__*/function (_Shape) {
  (0, _inherits2.default)(Text, _Shape);
  var _super = (0, _createSuper2.default)(Text);
  function Text() {
    (0, _classCallCheck2.default)(this, Text);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(Text, [{
    key: "_initProperties",
    value: function _initProperties() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Text.prototype), "_initProperties", this).call(this);
      this._attrs.canFill = true;
      this._attrs.canStroke = true;
      this._attrs.type = 'text';
    }
  }, {
    key: "getDefaultAttrs",
    value: function getDefaultAttrs() {
      return {
        lineWidth: 0,
        lineCount: 1,
        fontSize: 12,
        fontFamily: '',
        fontStyle: 'normal',
        fontWeight: 'normal',
        fontVariant: 'normal',
        textAlign: 'start',
        textBaseline: 'bottom',
        lineHeight: null,
        textArr: null
      };
    }
  }, {
    key: "_getFontStyle",
    value: function _getFontStyle() {
      var attrs = this._attrs.attrs;
      var fontSize = attrs.fontSize,
        fontFamily = attrs.fontFamily,
        fontWeight = attrs.fontWeight,
        fontStyle = attrs.fontStyle,
        fontVariant = attrs.fontVariant;
      return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
    }
  }, {
    key: "_afterAttrsSet",
    value: function _afterAttrsSet() {
      var attrs = this._attrs.attrs;
      attrs.font = this._getFontStyle();
      if (attrs.text) {
        var text = attrs.text;
        var textArr = null;
        var lineCount = 1;
        if ((0, _util.isString)(text) && text.indexOf('\n') !== -1) {
          textArr = text.split('\n');
          lineCount = textArr.length;
        }
        attrs.lineCount = lineCount;
        attrs.textArr = textArr;
      }
      this.set('attrs', attrs);
    }
  }, {
    key: "_getTextHeight",
    value: function _getTextHeight() {
      var attrs = this._attrs.attrs;
      if (attrs.height) {
        return attrs.height;
      }
      var lineCount = attrs.lineCount;
      var fontSize = attrs.fontSize * 1;
      if (lineCount > 1) {
        var spaceingY = this._getSpaceingY();
        return fontSize * lineCount + spaceingY * (lineCount - 1);
      }
      return fontSize;
    }
  }, {
    key: "_getSpaceingY",
    value: function _getSpaceingY() {
      var attrs = this._attrs.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    }
  }, {
    key: "drawInner",
    value: function drawInner(context) {
      var attrs = this._attrs.attrs;
      var text = attrs.text;
      var x = attrs.x;
      var y = attrs.y;
      if ((0, _util.isNil)(text) || isNaN(x) || isNaN(y)) {
        // text will be 0
        return;
      }
      var textArr = attrs.textArr;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      if (attrs.rotate) {
        // do rotation
        context.translate(x, y);
        context.rotate(attrs.rotate);
        x = 0;
        y = 0;
      }
      var textBaseline = attrs.textBaseline;
      var height;
      if (textArr) {
        height = this._getTextHeight();
      }
      var subY;
      // context.beginPath();
      if (this.hasFill()) {
        var fillOpacity = attrs.fillOpacity;
        if (!(0, _util.isNil)(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
        }
        if (textArr) {
          for (var i = 0, len = textArr.length; i < len; i++) {
            var subText = textArr[i];
            subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;
            if (textBaseline === 'middle') {
              subY += height - fontSize - (height - fontSize) / 2;
            }
            if (textBaseline === 'top') {
              subY += height - fontSize;
            }
            context.fillText(subText, x, subY);
          }
        } else {
          context.fillText(text, x, y);
        }
      }
      if (this.hasStroke()) {
        if (textArr) {
          for (var _i = 0, _len = textArr.length; _i < _len; _i++) {
            var _subText = textArr[_i];
            subY = y + _i * (spaceingY + fontSize) - height + fontSize; // bottom;
            if (textBaseline === 'middle') {
              subY += height - fontSize - (height - fontSize) / 2;
            }
            if (textBaseline === 'top') {
              subY += height - fontSize;
            }
            context.strokeText(_subText, x, subY);
          }
        } else {
          context.strokeText(text, x, y);
        }
      }
    }
  }, {
    key: "_getAriaLabel",
    value: function _getAriaLabel() {
      return this._attrs.attrs.text;
    }
  }, {
    key: "calculateBox",
    value: function calculateBox() {
      var attrs = this._attrs.attrs;
      var x = attrs.x,
        y = attrs.y,
        textAlign = attrs.textAlign,
        textBaseline = attrs.textBaseline;
      var width = this._getTextWidth(); // attrs.width
      if (!width) {
        return {
          minX: x,
          minY: y,
          maxX: x,
          maxY: y
        };
      }
      var height = this._getTextHeight(); // attrs.height
      if (attrs.rotate) {
        var rotatedBox = _rect.default.calcRotatedBox({
          width: width,
          height: height,
          rotate: attrs.rotate
        });
        width = rotatedBox.width;
        height = rotatedBox.height;
      }
      var point = {
        x: x,
        y: y - height
      }; // default textAlign: start, textBaseline: bottom
      if (textAlign) {
        if (textAlign === 'end' || textAlign === 'right') {
          point.x -= width;
        } else if (textAlign === 'center') {
          point.x -= width / 2;
        }
      }
      if (textBaseline) {
        if (textBaseline === 'top') {
          point.y += height;
        } else if (textBaseline === 'middle') {
          point.y += height / 2;
        }
      }
      return {
        minX: point.x,
        minY: point.y,
        maxX: point.x + width,
        maxY: point.y + height
      };
    }
  }, {
    key: "_getTextWidth",
    value: function _getTextWidth() {
      var attrs = this._attrs.attrs;
      if (attrs.width) {
        return attrs.width;
      }
      var text = attrs.text;
      var context = this.get('context');
      if ((0, _util.isNil)(text)) return undefined;
      var font = attrs.font;
      var textArr = attrs.textArr;
      var key = text + '' + font;
      if (textWidthCache[key]) {
        return textWidthCache[key];
      }
      var width = 0;
      if (textArr) {
        for (var i = 0, length = textArr.length; i < length; i++) {
          var subText = textArr[i];
          width = Math.max(width, measureText(subText, font, context).width);
        }
      } else {
        width = measureText(text, font, context).width;
      }
      if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
      }
      textWidthCacheCounter++;
      textWidthCache[key] = width;
      return width;
    }
  }]);
  return Text;
}(_shape.default);
var _default = Text;
exports.default = _default;