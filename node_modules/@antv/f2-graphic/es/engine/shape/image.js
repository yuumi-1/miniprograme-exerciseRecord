import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _get from "@babel/runtime/helpers/esm/get";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { isNil } from '@antv/util';
import Rect from './rect';
var imageCaches = {};
var ImageShape = /*#__PURE__*/function (_Rect) {
  _inherits(ImageShape, _Rect);
  var _super = _createSuper(ImageShape);
  function ImageShape() {
    _classCallCheck(this, ImageShape);
    return _super.apply(this, arguments);
  }
  _createClass(ImageShape, [{
    key: "_initProperties",
    value: function _initProperties() {
      _get(_getPrototypeOf(ImageShape.prototype), "_initProperties", this).call(this);
      this._attrs.canFill = false;
      this._attrs.canStroke = false;
      this._attrs.loading = false;
      this._attrs.image = null;
      this._attrs.type = 'image';
    }
  }, {
    key: "draw",
    value: function draw(context) {
      var _this = this;
      // 如果图片还在loading中直接返回，等下次绘制
      if (this.get('loading')) {
        return;
      }
      // 如果已经有image对象，直接绘制，会调用createPath绘制
      var image = this.get('image');
      if (image) {
        _get(_getPrototypeOf(ImageShape.prototype), "draw", this).call(this, context);
        return;
      }
      var attrs = this.get('attrs');
      var src = attrs.src,
        img = attrs.img;
      if (img) {
        this.set('image', img);
        _get(_getPrototypeOf(ImageShape.prototype), "draw", this).call(this, context);
        return;
      }
      if (src) {
        var cacheImage = this.get('cacheImage');
        // 如果有缓存，则直接从缓存中拿
        if (cacheImage && imageCaches[src]) {
          this.set('image', imageCaches[src]);
          this.draw(context);
          return;
        }
        var _image = null;
        var canvas = this.get('canvas');
        if (canvas && canvas.get('createImage')) {
          var createImage = canvas.get('createImage');
          _image = createImage();
        } else if (window.Image) {
          _image = new Image();
        }
        if (_image) {
          this.set('loading', true);
          // 设置跨域, 等同于 image.crossOrigin = 'anonymous'
          _image.crossOrigin = '';
          _image.onload = function () {
            _this.set('loading', false);
            _this.set('image', _image);
            // this.draw(context);
            // 这里需要调用 canvas.draw 进行重新绘制，否则 image 会一直在最上层
            canvas.draw();
          };
          // src 一定要在 crossOrigin 之后，否则 toDataURL 就会报 SecurityError
          _image.src = src;
          // 设置全局缓存
          if (cacheImage) {
            imageCaches[src] = _image;
          }
        }
      }
    }
  }, {
    key: "createPath",
    value: function createPath(context) {
      var image = this.get('image');
      this.drawImage(context, image);
    }
  }, {
    key: "drawImage",
    value: function drawImage(context, image) {
      var _this$_attrs = this._attrs,
        attrs = _this$_attrs.attrs,
        destroyed = _this$_attrs.destroyed;
      if (destroyed) {
        return;
      }
      var x = attrs.x,
        y = attrs.y,
        width = attrs.width,
        height = attrs.height,
        sx = attrs.sx,
        sy = attrs.sy,
        swidth = attrs.swidth,
        sheight = attrs.sheight,
        radius = attrs.radius,
        fillOpacity = attrs.fillOpacity;
      if (radius) {
        context.save();
        this.createRadiusPath(context, x, y, width, height, radius);
        context.clip();
      }
      // 设置透明度
      var originOpacity = context.globalAlpha;
      if (!isNil(fillOpacity)) {
        context.globalAlpha = fillOpacity;
      }
      if (!isNil(sx) && !isNil(sy) && !isNil(swidth) && !isNil(sheight)) {
        context.drawImage(image, sx, sy, swidth, sheight, x, y, width, height);
      } else {
        context.drawImage(image, x, y, width, height);
      }
      context.globalAlpha = originOpacity;
      if (radius) {
        // 因为 save 和 restore 会一定程度上影响绘图性能，所以只在必要是调用
        context.restore();
      }
    }
  }]);
  return ImageShape;
}(Rect);
export default ImageShape;