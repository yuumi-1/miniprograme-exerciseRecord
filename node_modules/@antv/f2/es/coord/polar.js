import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _get from "@babel/runtime/helpers/esm/get";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import Base from './base';
import { Vector2, Matrix } from '@antv/f2-graphic';
var Polar = /*#__PURE__*/function (_Base) {
  _inherits(Polar, _Base);
  var _super = _createSuper(Polar);
  function Polar() {
    var _this;
    _classCallCheck(this, Polar);
    _this = _super.apply(this, arguments);
    _this.type = 'polar';
    _this.isPolar = true;
    return _this;
  }
  _createClass(Polar, [{
    key: "update",
    value: function update(option) {
      _get(_getPrototypeOf(Polar.prototype), "update", this).call(this, option);
      if (!this.option) {
        this.option = option;
      }
      var _this$option = this.option,
        _this$option$radius = _this$option.radius,
        radiusRatio = _this$option$radius === void 0 ? 1 : _this$option$radius,
        _this$option$innerRad = _this$option.innerRadius,
        innerRadiusRatio = _this$option$innerRad === void 0 ? 0 : _this$option$innerRad;
      var width = this.width,
        height = this.height,
        _this$startAngle = this.startAngle,
        startAngle = _this$startAngle === void 0 ? -Math.PI / 2 : _this$startAngle,
        _this$endAngle = this.endAngle,
        endAngle = _this$endAngle === void 0 ? Math.PI * 3 / 2 : _this$endAngle;
      // 半径取宽高的最小值
      var radius = radiusRatio * (Math.min(width, height) / 2);
      // 极坐标下 x 表示弧度， y 代表 半径
      var x = [startAngle, endAngle];
      var y = [innerRadiusRatio * radius, radius];
      this.x = x;
      this.y = y;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.radius = radius;
      this.innnerRadius = innerRadiusRatio * radius;
      return this;
    }
  }, {
    key: "isCyclic",
    value: function isCyclic() {
      var startAngle = this.startAngle,
        endAngle = this.endAngle;
      if (endAngle - startAngle < Math.PI * 2) {
        return false;
      }
      return true;
    }
  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      var center = this.center,
        transposed = this.transposed,
        x = this.x,
        y = this.y;
      var xDim = transposed ? 'y' : 'x';
      var yDim = transposed ? 'x' : 'y';
      var _x = _slicedToArray(x, 2),
        xStart = _x[0],
        xEnd = _x[1];
      var _y = _slicedToArray(y, 2),
        yStart = _y[0],
        yEnd = _y[1];
      var angle = xStart + (xEnd - xStart) * point[xDim];
      var radius = yStart + (yEnd - yStart) * point[yDim];
      return {
        x: center.x + Math.cos(angle) * radius,
        y: center.y + Math.sin(angle) * radius
      };
    }
  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      var center = this.center,
        transposed = this.transposed,
        x = this.x,
        y = this.y;
      var xDim = transposed ? 'y' : 'x';
      var yDim = transposed ? 'x' : 'y';
      var _x2 = _slicedToArray(x, 2),
        xStart = _x2[0],
        xEnd = _x2[1];
      var _y2 = _slicedToArray(y, 2),
        yStart = _y2[0],
        yEnd = _y2[1];
      var m = [1, 0, 0, 1, 0, 0];
      Matrix.rotate(m, m, xStart);
      var startV = [1, 0];
      Vector2.transformMat2d(startV, startV, m);
      startV = [startV[0], startV[1]];
      var pointV = [point.x - center.x, point.y - center.y];
      if (Vector2.zero(pointV)) {
        return {
          x: 0,
          y: 0
        };
      }
      var theta = Vector2.angleTo(startV, pointV, xEnd < xStart);
      if (Math.abs(theta - Math.PI * 2) < 0.001) {
        theta = 0;
      }
      var l = Vector2.length(pointV);
      var percentX = theta / (xEnd - xStart);
      percentX = xEnd - xStart > 0 ? percentX : -percentX;
      var percentY = (l - yStart) / (yEnd - yStart);
      var rst = {};
      rst[xDim] = percentX;
      rst[yDim] = percentY;
      return rst;
    }
  }]);
  return Polar;
}(Base);
export default Polar;