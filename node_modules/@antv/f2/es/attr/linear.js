import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _get from "@babel/runtime/helpers/esm/get";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { Linear as LinearScale } from '@antv/scale';
import { isArray } from '@antv/util';
import { interpolate } from '../deps/d3-interpolate/src';
import Base from './base';
var Linear = /*#__PURE__*/function (_Base) {
  _inherits(Linear, _Base);
  var _super = _createSuper(Linear);
  function Linear(options) {
    var _this;
    _classCallCheck(this, Linear);
    _this = _super.call(this, options);
    _this._updateInterpolate();
    return _this;
  }
  _createClass(Linear, [{
    key: "createScale",
    value: function createScale(scaleConfig) {
      return new LinearScale(scaleConfig);
    }
  }, {
    key: "_updateInterpolate",
    value: function _updateInterpolate() {
      var _this$range = _slicedToArray(this.range, 2),
        min = _this$range[0],
        max = _this$range[1];
      this.interpolate = interpolate(min, max);
    }
  }, {
    key: "update",
    value: function update(options) {
      _get(_getPrototypeOf(Linear.prototype), "update", this).call(this, options);
      this._updateInterpolate();
    }
  }, {
    key: "_mapping",
    value: function _mapping(value) {
      var scale = this.scale,
        interpolate = this.interpolate;
      if (isArray(value)) {
        return value.map(function (v) {
          return interpolate(scale.scale(v));
        });
      }
      return interpolate(scale.scale(value));
    }
  }, {
    key: "normalize",
    value: function normalize(value) {
      var scale = this.scale;
      if (isArray(value)) {
        return value.map(function (v) {
          return scale.scale(v);
        });
      }
      return scale.scale(value);
    }
  }, {
    key: "convert",
    value: function convert(value) {
      var range = this.range;
      var _range = _slicedToArray(range, 2),
        min = _range[0],
        max = _range[1];
      if (isArray(value)) {
        return value.map(function (v) {
          return min + (max - min) * v;
        });
      }
      return min + (max - min) * value;
    }
  }]);
  return Linear;
}(Base);
export default Linear;