import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _get from "@babel/runtime/helpers/esm/get";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { jsx } from '../../jsx';
import { isArray } from '@antv/util';
import Geometry from '../geometry';
export default (function (View) {
  return /*#__PURE__*/function (_Geometry) {
    _inherits(Line, _Geometry);
    var _super = _createSuper(Line);
    function Line() {
      _classCallCheck(this, Line);
      return _super.apply(this, arguments);
    }
    _createClass(Line, [{
      key: "getDefaultCfg",
      value: function getDefaultCfg() {
        return {
          geomType: 'line',
          sortable: true
        };
      }
    }, {
      key: "splitPoints",
      value: function splitPoints(points) {
        var topPoints = [];
        var bottomPoints = [];
        for (var i = 0, len = points.length; i < len; i++) {
          var point = points[i];
          var x = point.x,
            y = point.y;
          topPoints.push(_objectSpread(_objectSpread({}, point), {}, {
            x: x,
            y: y[1]
          }));
          bottomPoints.push(_objectSpread(_objectSpread({}, point), {}, {
            x: x,
            y: y[0]
          }));
        }
        return [topPoints, bottomPoints];
      }
    }, {
      key: "splitNulls",
      value: function splitNulls(points, connectNulls) {
        if (connectNulls) {
          var _tmpPoints = [];
          for (var i = 0, len = points.length; i < len; i++) {
            var point = points[i];
            var x = point.x,
              y = point.y;
            // 过滤 x 为 NaN 的点
            if (isNaN(x)) {
              continue;
            }
            if (isArray(y)) {
              if (isNaN(y[0])) {
                continue;
              }
              _tmpPoints.push(point);
              continue;
            }
            if (isNaN(y)) {
              continue;
            }
            _tmpPoints.push(point);
          }
          if (_tmpPoints.length) {
            return [_tmpPoints];
          }
          return [];
        }
        var result = [];
        var tmpPoints = [];
        for (var _i = 0, _len = points.length; _i < _len; _i++) {
          var _point = points[_i];
          var _x = _point.x,
            _y = _point.y;
          // 过滤 x 为 NaN 的点
          if (isNaN(_x)) {
            continue;
          }
          if (isArray(_y)) {
            if (isNaN(_y[0])) {
              if (tmpPoints.length) {
                result.push(tmpPoints);
                tmpPoints = [];
              }
              continue;
            }
            tmpPoints.push(_point);
            continue;
          }
          if (isNaN(_y)) {
            if (tmpPoints.length) {
              result.push(tmpPoints);
              tmpPoints = [];
            }
            continue;
          }
          tmpPoints.push(_point);
        }
        if (tmpPoints.length) {
          result.push(tmpPoints);
        }
        return result;
      }
    }, {
      key: "mapping",
      value: function mapping() {
        var _this = this;
        var records = _get(_getPrototypeOf(Line.prototype), "mapping", this).call(this);
        var props = this.props,
          defaultConnectNulls = this.connectNulls;
        var coord = props.coord,
          _props$connectNulls = props.connectNulls,
          connectNulls = _props$connectNulls === void 0 ? defaultConnectNulls : _props$connectNulls;
        return records.map(function (record) {
          var children = record.children;
          // children 有可能为空
          var _ref = children[0] || {},
            size = _ref.size,
            color = _ref.color,
            shape = _ref.shape,
            y = _ref.y;
          // 极坐标时，需加入起点，从而闭合所绘图形
          var points = coord.isPolar ? [].concat(_toConsumableArray(children), [children[0]]) : children;
          var splitPoints = _this.splitNulls(points, connectNulls);
          var newChildren = splitPoints.map(function (points) {
            var _ref2 = isArray(y) ? _this.splitPoints(points) : [points, undefined],
              _ref3 = _slicedToArray(_ref2, 2),
              topPoints = _ref3[0],
              bottomPoints = _ref3[1];
            return {
              size: size,
              color: color,
              shape: shape,
              points: topPoints,
              bottomPoints: bottomPoints
            };
          });
          return _objectSpread(_objectSpread({}, record), {}, {
            children: newChildren
          });
        });
      }
    }, {
      key: "render",
      value: function render() {
        var props = this.props;
        var coord = props.coord;
        var records = this.mapping();
        var clip = this.getClip();
        return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
          coord: coord,
          records: records,
          clip: clip
        }));
      }
    }]);
    return Line;
  }(Geometry);
});