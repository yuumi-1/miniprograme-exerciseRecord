import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { each, isString, isNil, isFunction, isNumber, isArray, upperFirst } from '@antv/util';
import * as Attrs from '../attr';
import equal from '../base/equal';
var Identity = Attrs.Identity,
  Linear = Attrs.Linear,
  Category = Attrs.Category;
// 需要映射的属性名
var ATTRS = ['x', 'y', 'color', 'size', 'shape'];
// 分组处理的属性
var GROUP_ATTRS = ['color', 'size', 'shape'];
function cloneScale(scale, scaleConfig) {
  // @ts-ignore
  return new scale.constructor(_objectSpread(_objectSpread({}, scale.__cfg__), scaleConfig));
}
var AttrController = /*#__PURE__*/function () {
  function AttrController(scaleController, attrsRange) {
    _classCallCheck(this, AttrController);
    this.scaleController = scaleController;
    this.attrsRange = attrsRange;
    this.options = {};
    this.attrs = {};
  }
  _createClass(AttrController, [{
    key: "parseOption",
    value: function parseOption(option, attrName) {
      if (!option) {
        return {
          type: 'identity'
        };
      }
      if (isString(option)) {
        return {
          field: option,
          type: 'category'
        };
      }
      if (isNumber(option)) {
        if (attrName === 'size') {
          return {
            type: 'identity',
            field: option
          };
        }
      }
      if (isArray(option)) {
        return {
          field: option[0],
          range: option[1]
        };
      }
      return option;
    }
  }, {
    key: "getAttrOptions",
    value: function getAttrOptions(props, justifyContentCenter) {
      var _this = this;
      if (!props.x || !props.y) {
        throw new Error('x, y are required !');
      }
      var options = {};
      var ranges = this.attrsRange;
      ATTRS.forEach(function (attrName) {
        if (!props[attrName]) return;
        var option = _this.parseOption(props[attrName], attrName);
        if (!option.range) {
          option.range = ranges[attrName];
        }
        options[attrName] = option;
      });
      // @ts-ignore
      var x = options.x,
        y = options.y;
      x.justifyContent = justifyContentCenter;
      // x, y 都是固定Linear 映射
      x.type = Linear;
      y.type = Linear;
      return options;
    }
  }, {
    key: "getDefaultAttrValues",
    value: function getDefaultAttrValues() {
      var _this$attrsRange = this.attrsRange,
        color = _this$attrsRange.color,
        shape = _this$attrsRange.shape;
      return {
        color: color[0],
        shape: shape && shape[0]
      };
    }
  }, {
    key: "getGroupScales",
    value: function getGroupScales() {
      var attrs = this.attrs;
      var scales = [];
      each(GROUP_ATTRS, function (attrName) {
        var attr = attrs[attrName];
        if (!attr) {
          return;
        }
        var scale = attr.scale;
        if (scale && scale.isCategory && scales.indexOf(scale) === -1) {
          scales.push(scale);
        }
      });
      return scales;
    }
  }, {
    key: "createAttr",
    value: function createAttr(option) {
      var type = option.type,
        field = option.field,
        scaleConfig = option.scale;
      if (isNil(field) || type === Identity) {
        return new Identity(option);
      }
      var scale = this.scaleController.getScale(field);
      var attrOption = _objectSpread(_objectSpread({}, option), {}, {
        data: this.scaleController.getData(),
        // scaleConfig 只在属性映射中生效
        scale: scaleConfig ? cloneScale(scale, scaleConfig) : scale
      });
      // identity
      if (scale && scale.type === 'identity') {
        return new Identity(attrOption);
      }
      // Attr的默认类型和scale类型保持一致
      var AttrConstructor = scale.isLinear ? Linear : Category;
      // custom Attr Constructor
      if (isFunction(type)) {
        AttrConstructor = type;
      }
      if (isString(type) && Attrs[upperFirst(type)]) {
        AttrConstructor = Attrs[upperFirst(type)];
      }
      return new AttrConstructor(attrOption);
    }
  }, {
    key: "create",
    value: function create(options) {
      this.update(options);
    }
  }, {
    key: "update",
    value: function update(nextOptions) {
      var scaleController = this.scaleController,
        lastOptions = this.options,
        lastAttrs = this.attrs;
      var nextAttrs = {};
      each(nextOptions, function (nextOption, attrName) {
        var lastOption = lastOptions[attrName];
        if (equal(nextOption, lastOption)) {
          nextAttrs[attrName] = lastAttrs[attrName];
        }
        var field = nextOption.field,
          justifyContent = nextOption.justifyContent;
        if (field) {
          scaleController.setScale(field, {
            justifyContent: justifyContent
          });
        }
      });
      this.options = nextOptions;
      this.attrs = nextAttrs;
    }
  }, {
    key: "getAttr",
    value: function getAttr(attrName) {
      var attrs = this.attrs,
        options = this.options;
      var attr = attrs[attrName];
      if (attr) {
        return attr;
      }
      var option = options[attrName];
      if (!option) {
        return null;
      }
      var newAttr = this.createAttr(option);
      attrs[attrName] = newAttr;
      return newAttr;
    }
  }, {
    key: "getAttrs",
    value: function getAttrs() {
      var _this2 = this;
      var options = this.options,
        attrs = this.attrs;
      each(options, function (option, attrName) {
        _this2.getAttr(attrName);
      });
      return attrs;
    }
  }, {
    key: "isGroupAttr",
    value: function isGroupAttr(attrName) {
      return GROUP_ATTRS.indexOf(attrName) !== -1;
    }
  }, {
    key: "getAttrsByLinear",
    value: function getAttrsByLinear() {
      var attrs = this.attrs;
      var attrNames = Object.keys(attrs);
      var linearAttrs = [];
      var nonlinearAttrs = [];
      attrNames.forEach(function (attrName) {
        if (attrName === 'x' || attrName === 'y') {
          linearAttrs.push(attrName);
          return;
        }
        var scale = attrs[attrName].scale;
        if (scale && scale.type === 'linear') {
          linearAttrs.push(attrName);
        } else {
          nonlinearAttrs.push(attrName);
        }
      });
      return {
        linearAttrs: linearAttrs,
        nonlinearAttrs: nonlinearAttrs
      };
    }
  }]);
  return AttrController;
}();
export default AttrController;