"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));
var _base = _interopRequireDefault(require("./base"));
var _f2Graphic = require("@antv/f2-graphic");
var Polar = /*#__PURE__*/function (_Base) {
  (0, _inherits2.default)(Polar, _Base);
  var _super = (0, _createSuper2.default)(Polar);
  function Polar() {
    var _this;
    (0, _classCallCheck2.default)(this, Polar);
    _this = _super.apply(this, arguments);
    _this.type = 'polar';
    _this.isPolar = true;
    return _this;
  }
  (0, _createClass2.default)(Polar, [{
    key: "update",
    value: function update(option) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Polar.prototype), "update", this).call(this, option);
      if (!this.option) {
        this.option = option;
      }
      var _this$option = this.option,
        _this$option$radius = _this$option.radius,
        radiusRatio = _this$option$radius === void 0 ? 1 : _this$option$radius,
        _this$option$innerRad = _this$option.innerRadius,
        innerRadiusRatio = _this$option$innerRad === void 0 ? 0 : _this$option$innerRad;
      var width = this.width,
        height = this.height,
        _this$startAngle = this.startAngle,
        startAngle = _this$startAngle === void 0 ? -Math.PI / 2 : _this$startAngle,
        _this$endAngle = this.endAngle,
        endAngle = _this$endAngle === void 0 ? Math.PI * 3 / 2 : _this$endAngle;
      // 半径取宽高的最小值
      var radius = radiusRatio * (Math.min(width, height) / 2);
      // 极坐标下 x 表示弧度， y 代表 半径
      var x = [startAngle, endAngle];
      var y = [innerRadiusRatio * radius, radius];
      this.x = x;
      this.y = y;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.radius = radius;
      this.innnerRadius = innerRadiusRatio * radius;
      return this;
    }
  }, {
    key: "isCyclic",
    value: function isCyclic() {
      var startAngle = this.startAngle,
        endAngle = this.endAngle;
      if (endAngle - startAngle < Math.PI * 2) {
        return false;
      }
      return true;
    }
  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      var center = this.center,
        transposed = this.transposed,
        x = this.x,
        y = this.y;
      var xDim = transposed ? 'y' : 'x';
      var yDim = transposed ? 'x' : 'y';
      var _x = (0, _slicedToArray2.default)(x, 2),
        xStart = _x[0],
        xEnd = _x[1];
      var _y = (0, _slicedToArray2.default)(y, 2),
        yStart = _y[0],
        yEnd = _y[1];
      var angle = xStart + (xEnd - xStart) * point[xDim];
      var radius = yStart + (yEnd - yStart) * point[yDim];
      return {
        x: center.x + Math.cos(angle) * radius,
        y: center.y + Math.sin(angle) * radius
      };
    }
  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      var center = this.center,
        transposed = this.transposed,
        x = this.x,
        y = this.y;
      var xDim = transposed ? 'y' : 'x';
      var yDim = transposed ? 'x' : 'y';
      var _x2 = (0, _slicedToArray2.default)(x, 2),
        xStart = _x2[0],
        xEnd = _x2[1];
      var _y2 = (0, _slicedToArray2.default)(y, 2),
        yStart = _y2[0],
        yEnd = _y2[1];
      var m = [1, 0, 0, 1, 0, 0];
      _f2Graphic.Matrix.rotate(m, m, xStart);
      var startV = [1, 0];
      _f2Graphic.Vector2.transformMat2d(startV, startV, m);
      startV = [startV[0], startV[1]];
      var pointV = [point.x - center.x, point.y - center.y];
      if (_f2Graphic.Vector2.zero(pointV)) {
        return {
          x: 0,
          y: 0
        };
      }
      var theta = _f2Graphic.Vector2.angleTo(startV, pointV, xEnd < xStart);
      if (Math.abs(theta - Math.PI * 2) < 0.001) {
        theta = 0;
      }
      var l = _f2Graphic.Vector2.length(pointV);
      var percentX = theta / (xEnd - xStart);
      percentX = xEnd - xStart > 0 ? percentX : -percentX;
      var percentY = (l - yStart) / (yEnd - yStart);
      var rst = {};
      rst[xDim] = percentX;
      rst[yDim] = percentY;
      return rst;
    }
  }]);
  return Polar;
}(_base.default);
var _default = exports.default = Polar;