"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateFollow = updateFollow;
exports.updateRange = updateRange;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _scale = require("@antv/scale");
var _util = require("@antv/util");
var _util2 = require("../../util");
// 判断新老values是否相等，这里只要判断前后是否相等即可
function isValuesEqual(values, newValues) {
  if (values.length !== newValues.length) {
    return false;
  }
  var lastIndex = values.length - 1;
  return values[0] === newValues[0] && values[lastIndex] === newValues[lastIndex];
}
function updateCategoryRange(scale, originScale, range) {
  var currentValues = scale.values,
    currentTicks = scale.ticks,
    tickMethod = scale.tickMethod,
    tickCount = scale.tickCount;
  var originValues = originScale.values;
  var _range = (0, _slicedToArray2.default)(range, 2),
    start = _range[0],
    end = _range[1];
  var len = originValues.length;
  var valueStart = start * len;
  var valueEnd = end * len;
  // 保持滑动时个数的稳定
  var count = Math.round(valueEnd - valueStart);
  var sliceSatrt = Math.round(valueStart);
  // 从原始数据里截取需要显示的数据
  var newValues = originValues.slice(sliceSatrt, sliceSatrt + count);
  // 根据当前数据的比例，和定义的tickCount计算应该需要多少个ticks
  var newTickCount = Math.round(tickCount * originValues.length / newValues.length);
  // 计算新的ticks
  var catTicks = (0, _scale.getTickMethod)(tickMethod);
  var newTicks = catTicks({
    tickCount: newTickCount,
    values: originValues
  });
  // 如果新数组和当前显示的数组相同，则不更新
  if (isValuesEqual(currentValues, newValues) && isValuesEqual(currentTicks, newTicks)) {
    return;
  }
  scale.change({
    values: newValues,
    ticks: newTicks
  });
  return scale;
}
function updateLinearRange(scale, originScale, range) {
  var min = originScale.min,
    max = originScale.max;
  var _range2 = (0, _slicedToArray2.default)(range, 2),
    start = _range2[0],
    end = _range2[1];
  var newMin = min + (max - min) * start;
  var newMax = min + (max - min) * end;
  scale.change({
    min: newMin,
    max: newMax,
    nice: false
  });
}
function updateScale(scale, values) {
  var isLinear = scale.isLinear;
  if (isLinear) {
    var _getRange = (0, _util.getRange)(values),
      min = _getRange.min,
      max = _getRange.max;
    return scale.change({
      min: min,
      max: max,
      nice: true
    });
  }
}
function updateRange(scale, originScale, range) {
  var isCategory = scale.isCategory,
    isLinear = scale.isLinear;
  if (isCategory) {
    return updateCategoryRange(scale, originScale, range);
  }
  if (isLinear) {
    return updateLinearRange(scale, originScale, range);
  }
}
function updateFollow(scales, mainScale, data) {
  var mainField = mainScale.field,
    mainType = mainScale.type,
    mainValues = mainScale.values;
  // 转成 map 提高查询性能
  var mainValuesMap = {};
  mainValues.forEach(function (item) {
    mainValuesMap[item] = true;
  });
  return scales.map(function (scale) {
    var followField = scale.field;
    var values = [];
    data.forEach(function (item) {
      var value = mainType === 'timeCat' ? (0, _util2.toTimeStamp)(item[mainField]) : item[mainField];
      if (mainValuesMap[value]) {
        values.push(item[followField]);
      }
    });
    return updateScale(scale, values);
  });
}